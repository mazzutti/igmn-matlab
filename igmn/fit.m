function [instance, fval, exitFlag, output] = fit(data, outVars, options) %#codegen
    arguments
        data (:,:) {mustBeNumeric, mustBeNonempty};
        outVars (1,:) {mustBeInteger} = [size(data, 2)];
        options struct { ...
            mustBeMemberOf(options, { ...
                'algorithm', ...
                'lb', ...
                'ub', ...
                'folds', ...
                'maxIters', ...
                'parallel', ...
                'display' ...
            }), ...
            mustBeMemberOf(options, { ...
                'ga',  ...
                'particleswarm', ...
                'patternsearch' ...
            }, 'algorithm'), ...
            mustBeBetween(options, 'lb', [0, 1]), ...
            mustBeBetween(options, 'ub', [0, 1]), ...
            mustBeIntegerGreaterThan(options, 'folds', 0), ...
            mustBeIntegerGreaterThan(options, 'maxIters', 0), ...
            mustBeBoolean(options, 'parallel'), ...
            mustBeMemberOf(options, { ...
                'off',  ...
                'iter', ...
                'final' ...
            }, 'display'), ...
            mustBeBoolean(options, 'useGpu') ...
        } = struct();
    end
    options = mergeOptions(options, ...
        struct(...
            'algorithm', "particleswarm", ...
            'lb', [
                    igmn.minTau, ...             % min tau
                    igmn.minTau ...              % min delta  
                ], ...
            'ub', [
                    1.0 - (2 * igmn.minTau), ... % max tau
                    1.0 - igmn.minTau ...        % max delta   
                ], ...
            'folds', 6, ...
            'maxIters', 3 * 100, ...
            'parallel', true ...
        ) ...
    );
    coder.gpu.kernelfun;
    
    range = max(data) - min(data); 
    
    optimizeFun = @(x) optimize(data, outVars, range, x, options);
    
    nVars = 2;
    lb = options('lb');
    ub = options('ub');
    
    switch options.algorithm
        case "ga"
            algOptions = optimoptions(...
                options.algorithm, ...
                'Display', options.display, ...
                'UseParallel', options.parallel, ...
                'MaxGenerations', options.maxIters, ...
                'PlotFcn', 'gaplotbestf');
            [x, fval, exitFlag, output] = ga(optimizeFun, nVars, ...
                [], [], [], [], lb, ub, [], [], algOptions);
        case "particleswarm"
            algOptions = optimoptions(...
                options.algorithm, ...
                'Display', options.display , ...
                'UseParallel', options.parallel, ...
                'MaxIterations', options.maxIters, ...
                'PlotFcn','pswplotbestf');
            [x, fval, exitFlag, output] = particleswarm( ...
                optimizeFun, nVars, lb, ub, algOptions);
            
        case "patternsearch"
            x0 = [
                igmn.defaultTau, ...
                igmn.defaultDelta ...
            ];
            algOptions = optimoptions(...
                options.algorithm, ...
                'Display', options.display, ...
                'UseParallel', options.parallel, ...
                'MaxIterations', options.maxIters, ...
                'MeshTolerance', 1e-18, ...
                'TolX', 1e-12, ...
                'PlotFcn','psplotbestf');
            [x, fval, exitFlag, output] = patternsearch( ...
                optimizeFun, x0, [], [], ...
                [], [], lb, ub, [], algOptions);
    end
    
    instance = igmn(range, struct('tau', x(1), 'delta', x(2), 'spMin', 3));
    instance = train(instance, data);
end


function result = optimize(data, outVars, range, x, options) %#codegen
    folds = options('folds');
    coder.gpu.kernelfun;
    model = igmn(range, struct('tau', x(1), 'delta', x(2), 'spMin', 3));
    rmses = zeros(1, folds);
    inputVars = 1:size(data, 2);
    inputVars(outVars) = [];
    smfLimits = [0, model.vMin ^ model.spMin];
    for i = 1:folds
        [trainData, testData] = splitData(data, 0.8);
        model = train(model, trainData);
        input = testData(:, inputVars);
        y = testData(:, outVars);
        pred = predict(model, input);
        penalty = smf(model.nc, smfLimits);
        rmses(i) = sum(sqrt(mean((y - pred) .^ 2))) + penalty;
        model = resetState(model);
    end
    result = mean(rmses);
end

function defaults = mergeOptions(options, defaults) %#codegen
    coder.gpu.kernelfun;
    if isfield(options, 'algorithm'); defaults.algorithm = options.algorithm;end
    if isfield(options, 'lb'); defaults.lb = options.lb;end
    if isfield(options, 'ub'); defaults.ub = options.ub;end
    if isfield(options, 'folds'); defaults.folds = options.folds;end
    if isfield(options, 'maxIters'); defaults.maxIters = options.maxIters;end
    if isfield(options, 'parallel'); defaults.parallel = options.parallel;end
end


