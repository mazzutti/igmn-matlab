<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of imode</title>
  <meta name="keywords" content="imode">
  <meta name="description" content="{">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">igmn</a> &gt; <a href="index.html">private</a> &gt; imode.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for igmn/private&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>imode
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>{</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">{</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="extractBounds.html" class="code" title="function [lbRow, ubRow, nhps] = extractBounds(hyperparameters, hpIndexes) %#codegen">extractBounds</a>	extractBounds - Extracts the lower and upper bounds of hyperparameters.</li><li><a href="extractHyperarameterNames.html" class="code" title="function [hpNames, hpIndexes] = extractHyperarameterNames(optOptions)">extractHyperarameterNames</a>	extractHyperarameterNames - Extracts the names and indexes of hyperparameters</li><li><a href="imode.html" class="code" title="">imode</a>	{</li><li><a href="initialPopulationCheck.html" class="code" title="function options = initialPopulationCheck(options) %#codegen">initialPopulationCheck</a>	initialPopulationCheck - Validates and adjusts the initial population for optimization.</li><li><a href="meanf.html" class="code" title="function m = meanf(x)">meanf</a>	MEANF Compute the mean of an array, ignoring NaN values.</li><li><a href="roundDiscreteHyperparameters.html" class="code" title="function population = roundDiscreteHyperparameters(population, hyperparameters, hpIndexes) %#codegen">roundDiscreteHyperparameters</a>	roundDiscreteHyperparameters - Rounds discrete hyperparameters in a population matrix.</li><li><a href="validateOptimizationOptions.html" class="code" title="">validateOptimizationOptions</a>	{</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="imode.html" class="code" title="">imode</a>	{</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [x, fval, exitFlag] = imode(problem)</a></li><li><a href="#_sub2" class="code">function [x,fval,exitFlag] = imodecore(nhps, lbRow, ubRow, problem, hpNames, hpIndexes)</a></li><li><a href="#_sub3" class="code">function optimValues = i_updateOptimValues</a></li><li><a href="#_sub4" class="code">function newPositions = updatePositions(</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%{</span>
0002 imode.m - Perform optimization using the IMODE algorithm.
0003 
0004 This script contains the implementation of the IMODE (Improved Multi-Operator Differential Evolution) 
0005 algorithm <span class="keyword">for</span> optimization. It includes the main <span class="keyword">function</span> `imode` and its core implementation 
0006 `imodecore`, along with helper functions <span class="keyword">for</span> updating positions and managing the optimization state.
0007 
0008 FUNCTIONS:
0009 1. <a href="imode.html" class="code" title="">imode</a>(problem)
0010     - Main entry point <span class="keyword">for</span> the IMODE optimization algorithm.
0011     - Parameters:
0012       - problem: A structure containing the optimization problem definition and options.
0013     - Returns:
0014       - x: The best solution found.
0015       - fval: The objective <span class="keyword">function</span> value at the best solution.
0016       - exitFlag: A flag indicating the reason <span class="keyword">for</span> termination.
0017 
0018 2. <a href="#_sub2" class="code" title="subfunction [x,fval,exitFlag] = imodecore(nhps, lbRow, ubRow, problem, hpNames, hpIndexes)">imodecore</a>(nhps, lbRow, ubRow, problem, hpNames, hpIndexes)
0019     - Core implementation of the IMODE algorithm.
0020     - Parameters:
0021       - nhps: Number of hyperparameters.
0022       - lbRow: Lower bounds <span class="keyword">for</span> hyperparameters.
0023       - ubRow: Upper bounds <span class="keyword">for</span> hyperparameters.
0024       - problem: The optimization problem structure.
0025       - hpNames: Names of hyperparameters.
0026       - hpIndexes: Indexes of hyperparameters.
0027     - Returns:
0028       - x: The best solution found.
0029       - fval: The objective <span class="keyword">function</span> value at the best solution.
0030       - exitFlag: A flag indicating the reason <span class="keyword">for</span> termination.
0031 
0032 3. <a href="#_sub4" class="code" title="subfunction newPositions = updatePositions( ">updatePositions</a>(state, lbRow, ubRow, pIdx, numIndividuals, nhps, hyperparameters, hpIndexes, F, OP, CR)
0033     - Updates the positions of individuals in the population.
0034     - Parameters:
0035       - state: Current state of the optimization process.
0036       - lbRow: Lower bounds <span class="keyword">for</span> hyperparameters.
0037       - ubRow: Upper bounds <span class="keyword">for</span> hyperparameters.
0038       - pIdx: Indexes of the current population.
0039       - numIndividuals: Number of individuals in the population.
0040       - nhps: Number of hyperparameters.
0041       - hyperparameters: Hyperparameter definitions.
0042       - hpIndexes: Indexes of hyperparameters.
0043       - F: Scaling factors <span class="keyword">for</span> mutation.
0044       - OP: Operators <span class="keyword">for</span> generating offspring.
0045       - CR: Crossover probabilities.
0046     - Returns:
0047       - newPositions: Updated positions of individuals.
0048 
0049 NOTES:
0050 - The IMODE algorithm uses a combination of mutation, crossover, and selection operators to evolve 
0051   a population of candidate solutions.
0052 - The algorithm supports parallel computation <span class="keyword">for</span> evaluating the objective function.
0053 - Stopping criteria include maximum <span class="keyword">function</span> evaluations, stall iterations, and user-defined conditions.
0054 - The implementation includes support <span class="keyword">for</span> plotting and monitoring the optimization process.
0055 
0056 USAGE:
0057 - Define the optimization problem and options in the `problem` structure.
0058 - Call the `imode` <span class="keyword">function</span> with the problem structure to perform optimization.
0059 - The best solution and its objective <span class="keyword">function</span> value are returned upon completion.
0060 
0061 DEPENDENCIES:
0062 - This implementation relies on several helper functions, such as `extractHyperarameterNames`, 
0063   `extractBounds`, `validateOptimizationOptions`, `initialPopulationCheck`, `evaluate`, 
0064   `makeOptimizationState`, `stopOptimization`, and `roundDiscreteHyperparameters`.
0065 
0066 <span class="comment">%}</span>
0067 <a name="_sub0" href="#_subfunctions" class="code">function [x, fval, exitFlag] = imode(problem) </a><span class="comment">%#codegen</span>
0068 
0069     optOptions = problem.OptimizeOptions;
0070     [hpNames, hpIndexes] = <a href="extractHyperarameterNames.html" class="code" title="function [hpNames, hpIndexes] = extractHyperarameterNames(optOptions)">extractHyperarameterNames</a>(optOptions);
0071 
0072     [lbRow , ubRow, nhps] =  <a href="extractBounds.html" class="code" title="function [lbRow, ubRow, nhps] = extractBounds(hyperparameters, hpIndexes) %#codegen">extractBounds</a>(optOptions.hyperparameters, hpIndexes); 
0073     
0074     optOptions = <a href="validateOptimizationOptions.html" class="code" title="">validateOptimizationOptions</a>(optOptions, nhps, hpIndexes);
0075     
0076     <span class="comment">% Perform check on initial population, fvals, and range</span>
0077     problem.OptimizeOptions = <a href="initialPopulationCheck.html" class="code" title="function options = initialPopulationCheck(options) %#codegen">initialPopulationCheck</a>(optOptions);
0078 
0079     <span class="comment">% Start the core algorithm</span>
0080     [x, fval, exitFlag] = <a href="#_sub2" class="code" title="subfunction [x,fval,exitFlag] = imodecore(nhps, lbRow, ubRow, problem, hpNames, hpIndexes)">imodecore</a>(nhps, lbRow, ubRow, problem, hpNames, hpIndexes);
0081 <span class="keyword">end</span>
0082 
0083 <a name="_sub1" href="#_subfunctions" class="code">function [x,fval,exitFlag] = imodecore(nhps, lbRow, ubRow, problem, hpNames, hpIndexes)</a>
0084     coder.extrinsic(<span class="string">'callPlotFcns'</span>);
0085 
0086     optOptions = problem.OptimizeOptions;
0087 
0088     exitFlag = [];
0089     coder.varsize(<span class="string">'exitFlag'</span>);
0090    
0091     <span class="comment">% Get algorithmic options</span>
0092     minN = optOptions.MinPopulationSize;
0093     aRate = optOptions.PopulationArquiveRate;
0094     hyperparameters = optOptions.hyperparameters;
0095     numIndividuals = optOptions.PopulationSize;
0096     lbMatrix = repmat(lbRow, numIndividuals, 1);
0097     ubMatrix = repmat(ubRow, numIndividuals, 1);
0098 
0099     range = problem.DefaultIgmnOptions.range;
0100     outVarIndexes = problem.OutputVarIndexes;
0101     maxPenalty = 0.125 * mean( <span class="keyword">...</span>
0102         range(2, outVarIndexes) - range(1, outVarIndexes), <span class="string">'all'</span>);
0103     
0104     objFun = @(params) evaluate(params, problem, hpNames, maxPenalty);
0105 
0106     state = makeOptimizationState(nhps, lbMatrix, ubMatrix, optOptions, objFun, hpIndexes);
0107     bestFvals = min(state.Fvals, [], &quot;all&quot;);
0108 
0109     <span class="comment">% Create a vector to store the last StallIterLimit bestFvals.</span>
0110     <span class="comment">% bestFvalsWindow is a circular buffer, so that the value from the i'th</span>
0111     <span class="comment">% iteration is stored in element with index mod(i-1,StallIterLimit)+1.</span>
0112     bestFvalsWindow = nan(optOptions.StallIterLimit, 1);
0113 
0114     <span class="comment">% Allow plot functions to perform any initialization tasks</span>
0115     <span class="keyword">if</span> isempty(optOptions.PlotFcns)
0116         haveplotfcn = false;
0117     <span class="keyword">else</span>
0118         <span class="keyword">if</span> coder.target(<span class="string">'MATLAB'</span>) || coder.target(<span class="string">'MEX'</span>)
0119             haveplotfcn = true;
0120             state.StopFlag = callPlotFcns(<a href="#_sub3" class="code" title="subfunction optimValues = i_updateOptimValues">i_updateOptimValues</a>, <span class="string">'init'</span>);
0121             <span class="comment">% check to see if any stopping criteria have been met</span>
0122             exitFlag = stopOptimization(optOptions, state, bestFvalsWindow);
0123         <span class="keyword">else</span>
0124             haveplotfcn = false;
0125         <span class="keyword">end</span>
0126     <span class="keyword">end</span>
0127 
0128     <span class="comment">% Setup display header</span>
0129     <span class="keyword">if</span>  optOptions.Verbosity &gt; 1
0130         bestFvalDisplay = bestFvals;
0131         meanFvalDisplay = mean(state.Fvals, <span class="string">'all'</span>);
0132         fprintf(<span class="string">'\n                                 Best            Mean    Stall\n'</span>);
0133         fprintf(  <span class="string">'Iteration     f-count            f(x)            f(x)    Iterations\n'</span>);
0134         fprintf(<span class="string">'%5.0f         %7.0f    %12.4g    %12.4g    %5.0f\n'</span>, <span class="keyword">...</span>
0135             0, state.FunEval, bestFvalDisplay, meanFvalDisplay, 0);
0136         pause(0.000001);
0137     <span class="keyword">end</span>
0138 
0139     <span class="comment">%% Optimization</span>
0140     <span class="keyword">while</span> isempty(exitFlag)
0141 
0142         state.Iteration = state.Iteration + 1;
0143 
0144         <span class="comment">% Reduce the population size</span>
0145         numIndividuals = ceil((minN - optOptions.PopulationSize) <span class="keyword">...</span>
0146             * state.FunEval / optOptions.MaxFunEval) + optOptions.PopulationSize;
0147         pIdx = 1:numIndividuals;
0148 
0149         [~, rank] = sort(state.Fvals);
0150         indexes = (1:numIndividuals)';
0151         state.Positions = state.Positions(rank(indexes), :);
0152         state.Fvals = state.Fvals(rank(indexes), :);
0153         state.Archive = state.Archive(randperm(<span class="keyword">end</span>, min(<span class="keyword">end</span>, ceil(aRate * numIndividuals))), :);
0154         CR = randn(numIndividuals, 1) .* sqrt(0.1) + state.MCR(randi(<span class="keyword">end</span>, numIndividuals, 1));
0155         CR = sort(CR);
0156         CR = repmat(max(0, min(1, CR)), 1, nhps);
0157         F = min(1, trnd(1, numIndividuals, 1) .* sqrt(0.1) + state.MF(randi(<span class="keyword">end</span>, numIndividuals, 1)));
0158         <span class="keyword">while</span> any(F &lt;= 0)
0159             F(F &lt;= 0) = min(1, trnd(1, sum(F &lt;= 0), 1) .* sqrt(0.1) + state.MF(randi(<span class="keyword">end</span>, sum(F &lt;= 0), 1)));
0160         <span class="keyword">end</span>
0161         F  = repmat(F, 1, nhps);
0162 
0163         mopSum = cumsum(state.MOP);
0164         OP1 = []; coder.varsize(<span class="string">'OP1'</span>);
0165         OP2 = []; coder.varsize(<span class="string">'OP2'</span>);
0166         OP3 = []; coder.varsize(<span class="string">'OP3'</span>);
0167         OP = {OP1, OP2, OP3};
0168         <span class="keyword">for</span> i = 1:numIndividuals
0169             index = find(rand &lt;= mopSum, 1);
0170             OP{index} = [OP{index}, i];
0171         <span class="keyword">end</span>
0172 
0173         newPositions = <a href="#_sub4" class="code" title="subfunction newPositions = updatePositions( ">updatePositions</a>(state, lbRow, <span class="keyword">...</span>
0174                 ubRow, pIdx, numIndividuals, nhps, hyperparameters, hpIndexes, F, OP, CR);
0175         
0176         popSize = size(newPositions, 1);
0177         fvals = zeros(popSize, 1);
0178         <span class="keyword">if</span> optOptions.UseParallel
0179             setenv(<span class="string">'OMP_NUM_THREADS'</span>, <span class="string">'12'</span>);
0180             parfor (i = 1:popSize, 12)
0181                 fvals(i) = objFun(newPositions(i, :));
0182             <span class="keyword">end</span>
0183         <span class="keyword">else</span>
0184             <span class="keyword">for</span> i = 1:popSize
0185                 fvals(i) = objFun(newPositions(i, :));
0186             <span class="keyword">end</span>
0187         <span class="keyword">end</span> 
0188         <span class="comment">% Update the population and archive</span>
0189         delta = state.Fvals - fvals;
0190         replace = delta &gt; 0;
0191         state.Archive = [state.Archive; state.Positions(replace, :)];
0192         state.Archive = state.Archive(randperm(<span class="keyword">end</span>, min(<span class="keyword">end</span>, ceil(aRate * numIndividuals))), :);
0193         state.Positions(replace, :) = newPositions(replace, :);
0194         state.Fvals(replace) = fvals(replace);
0195 
0196         <span class="comment">% Update CR, F, and probabilities of operators</span>
0197         <span class="keyword">if</span> any(replace)
0198             w = delta(replace) ./ sum(delta(replace));
0199             state.MCR(state.k) = (w' * CR(replace, 1) .^ 2) ./ (w' * CR(replace, 1));
0200             state.MF(state.k)  = (w' * F(replace, 1) .^ 2) ./ (w' * F(replace, 1));
0201             state.k = mod(state.k, length(state.MCR)) + 1;
0202         <span class="keyword">else</span>
0203             state.MCR(state.k) = 0.5;
0204             state.MF(state.k) = 0.5;
0205         <span class="keyword">end</span>
0206         delta = max(0, delta ./ abs(state.Fvals));
0207         <span class="keyword">if</span> any(arrayfun(@(i) isempty(OP{i}), 1:length(OP)))
0208             state.MOP = ones(1, 3) / 3;
0209         <span class="keyword">else</span>
0210             mop = zeros(1, length(OP));
0211             <span class="keyword">for</span> i = 1:length(OP);  mop(i) = mean(delta(OP{i}')); <span class="keyword">end</span>
0212             state.MOP = max(0.1, min(0.9, mop ./ sum(mop)));
0213         <span class="keyword">end</span>
0214 
0215         <span class="comment">% Update state with best fvals and best individual positions.</span>
0216         state = updateState(state, numIndividuals, pIdx');
0217 
0218         <span class="comment">% Call plot functions</span>
0219         <span class="keyword">if</span> haveplotfcn
0220             <span class="keyword">if</span> coder.target(<span class="string">'MATLAB'</span>) || coder.target(<span class="string">'MEX'</span>)
0221                 state.StopFlag = callPlotFcns(<a href="#_sub3" class="code" title="subfunction optimValues = i_updateOptimValues">i_updateOptimValues</a>, <span class="string">'iter'</span>);
0222             <span class="keyword">end</span>
0223         <span class="keyword">else</span>
0224             state.StopFlag = false;
0225         <span class="keyword">end</span>
0226 
0227         bestFvalsWindow(1 + mod(state.Iteration - 1, optOptions.StallIterLimit)) = min(state.IndividualBestFvals);
0228         
0229         newBest = min(state.IndividualBestFvals, [], &quot;all&quot;);
0230         <span class="keyword">if</span> isfinite(newBest) &amp;&amp; newBest &lt; bestFvals
0231             bestFvals = newBest;
0232             state.LastImprovement = state.Iteration;
0233             state.LastImprovementTime = toc(state.StartTime);
0234         <span class="keyword">end</span>
0235 
0236         <span class="comment">% check to see if any stopping criteria have been met</span>
0237         exitFlag  = stopOptimization(optOptions, state, bestFvalsWindow);
0238     <span class="keyword">end</span>
0239 
0240     <span class="comment">% Find and return the best solution</span>
0241     [fval, indexBestFval] = min(state.IndividualBestFvals);
0242     x = state.IndividualBestPositions(indexBestFval, :);
0243     
0244 
0245     <span class="comment">% Allow output and plot functions to perform any clean up tasks.</span>
0246     <span class="keyword">if</span> haveplotfcn
0247         <span class="keyword">if</span> coder.target(<span class="string">'MATLAB'</span>) || coder.target(<span class="string">'MEX'</span>)
0248             callPlotFcns(<a href="#_sub3" class="code" title="subfunction optimValues = i_updateOptimValues">i_updateOptimValues</a>, <span class="string">'done'</span>);
0249         <span class="keyword">end</span>
0250     <span class="keyword">end</span>
0251 
0252     <span class="comment">% Nested function</span>
0253     <a name="_sub2" href="#_subfunctions" class="code">function optimValues = i_updateOptimValues</a>
0254         optimValues.bestfval = min(state.IndividualBestFvals);
0255         optimValues.iteration = state.Iteration;
0256         optimValues.meanfval = <a href="meanf.html" class="code" title="function m = meanf(x)">meanf</a>(state.Fvals);
0257         optimValues.population = state.Positions;
0258         optimValues.populationRange = state.PopulationRange;
0259         optimValues.populationfvals = state.Fvals;
0260         optimValues.plotFcns = state.PlotFcns;
0261         optimValues.hpNames = hpNames;
0262         optimValues.algorithm = <span class="string">'IMODE'</span>;
0263     <span class="keyword">end</span>
0264 <span class="keyword">end</span>
0265 
0266 <a name="_sub3" href="#_subfunctions" class="code">function newPositions = updatePositions( </a><span class="keyword">...</span>
0267     state, lbRow, ubRow, pIdx, numIndividuals, nhps, hyperparameters, hpIndexes, F, OP, CR) <span class="comment">%#codegen</span>
0268      <span class="comment">% Generate parents, CR, F, and operator for each offspring</span>
0269     Xp1 = state.Positions(ceil(rand(1, numIndividuals) .* max(1, 0.25 * numIndividuals)), :);
0270     Xp2 = state.Positions(ceil(rand(1, numIndividuals) .* max(2, 0.5 * numIndividuals)), :);
0271     Xr1 = state.Positions(randi(<span class="keyword">end</span>, 1, numIndividuals), :);
0272     Xr3 = state.Positions(randi(<span class="keyword">end</span>, 1, numIndividuals), :);
0273     P = [state.Positions; state.Archive];
0274     Xr2 = P(randi(<span class="keyword">end</span>, 1, numIndividuals), :);
0275 
0276     <span class="comment">% Generate offspring</span>
0277     newPositions = state.Positions(:, :);
0278     newPositions(OP{1}, :) = state.Positions(OP{1}, :) + F(OP{1}, :) .* <span class="keyword">...</span>
0279         (Xp1(OP{1}, :) - state.Positions(OP{1}, :) + Xr1(OP{1}, :) - Xr2(OP{1}, :));
0280     newPositions(OP{2}, :) = state.Positions(OP{2}, :) + F(OP{2}, :) .* <span class="keyword">...</span>
0281         (Xp1(OP{2}, :) - state.Positions(OP{2}, :) + Xr1(OP{2}, :) - Xr3(OP{2}, :));
0282     newPositions(OP{3}, :) = F(OP{3}, :) .* (Xr1(OP{3}, :) + Xp2(OP{3}, :) - Xr3(OP{3}, :));
0283     <span class="keyword">if</span> rand &lt; 0.4
0284         Site = rand(size(CR)) &gt; CR;
0285         newPositions(Site) = state.Positions(Site);
0286     <span class="keyword">else</span>
0287         p1 = randi(nhps, numIndividuals, 1);
0288         p2 = zeros(1, numIndividuals);
0289         <span class="keyword">for</span> i = 1:numIndividuals
0290             p2(i) = find([rand(1, nhps), 2] &gt; CR(i, 1), 1);
0291         <span class="keyword">end</span>
0292         <span class="keyword">for</span> i = 1 :numIndividuals
0293             Site = [1:p1(i) - 1, p1(i) + p2(i):nhps];
0294             newPositions(i, Site) = state.Positions(i, Site);
0295         <span class="keyword">end</span>
0296     <span class="keyword">end</span>
0297 
0298     newPositions = <a href="roundDiscreteHyperparameters.html" class="code" title="function population = roundDiscreteHyperparameters(population, hyperparameters, hpIndexes) %#codegen">roundDiscreteHyperparameters</a>(newPositions, hyperparameters, hpIndexes);
0299     
0300     <span class="comment">% Remove positions if infinite.</span>
0301     tfInvalid = any(~isfinite(newPositions), 2);
0302     tfInvalidFull = false(numIndividuals, 1);
0303     tfInvalidFull(pIdx) = tfInvalid;
0304     newPositions(tfInvalid, :) = state.Positions(tfInvalidFull, :);
0305 
0306     lbMatrix = repmat(lbRow, numIndividuals, 1);
0307     ubMatrix = repmat(ubRow, numIndividuals, 1);
0308     
0309     <span class="comment">% Enforce bounds on positions and return logical array to update velocities where position exceeds bounds.</span>
0310     tfInvalidLB = newPositions &lt; lbMatrix(pIdx, :);
0311     <span class="keyword">if</span> any(tfInvalidLB(:))
0312         tfInvalidLBFull = false(numIndividuals, nhps);
0313         tfInvalidLBFull(pIdx, :) = tfInvalidLB;
0314         newPositions(tfInvalidLB) = lbMatrix(tfInvalidLBFull);
0315     <span class="keyword">end</span>
0316     
0317     tfInvalidUB = newPositions &gt; ubMatrix(pIdx,:);
0318     <span class="keyword">if</span> any(tfInvalidUB(:))
0319         tfInvalidUBFull = false(numIndividuals,nhps);
0320         tfInvalidUBFull(pIdx,:) = tfInvalidUB;
0321         newPositions(tfInvalidUB) = ubMatrix(tfInvalidUBFull);
0322     <span class="keyword">end</span> 
0323 <span class="keyword">end</span>
0324</pre></div>
<hr><address>Generated on Sun 13-Apr-2025 23:43:31 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>